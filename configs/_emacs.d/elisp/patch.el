;;; patch.el --- derived from hexl.el, hideif.el
;;; Copyright 1997 Pavel Machek <pavel@atrey.karlin.mff.cuni.cz>
;;; No warranty given, distribute according to GPL.

;;; Code:

;;; Place diffcvt into /usr/libexec/emacs/19.34/i486-linux/diffcvt (or
;;; similar) directory *OR* place it anywhere else and edit patch-program
;;; to ../../../../../../../where/you/placed/it/diffcvt.

;;
;; vars here
;;

; Hint: /../../../../../../../../../path/diffcvt may help
(defvar patch-program "diffcvt"
  "The program that will patchify and depatchify its stdin.
`patch-program' will always be concatenated with `patch-options'
and \"-de\" when depatchifying a buffer.")

(defvar patchify-command
  (format "%s%s" exec-directory patch-program)
  "The command to use to patchify a buffer.")

(defvar depatchify-command
  (format "%s -d" patchify-command)
  "The command to use to unpatchify a buffer.")

(defvar patch-mode-map (make-sparse-keymap)
  "Keymap for Patch mode.")

(define-key patch-mode-map "\en" 'patch-next-hunk)
(define-key patch-mode-map "\eN" 'patch-next-file)
(define-key patch-mode-map "\ep" 'patch-prev-hunk)
(define-key patch-mode-map "\eP" 'patch-prev-file)
(define-key patch-mode-map "\ek" 'patch-kill-hunk)
(define-key patch-mode-map "\eK" 'patch-kill-file)

(defun patch-kill-hunk ()
  "Kill current hunk."
  (interactive)
  (progn
    (next-line 1)
    (re-search-backward "^\\@\\@")
    (setq killto (save-excursion 
		   (progn    
		     (next-line 1)
		     (re-search-forward "^\\@\\@") 
		     (beginning-of-line) 
		     (point))))
    (kill-region (point) killto)))

(defun patch-kill-file ()
  "Kill current file (or section corresponding to one file in patch)."
  (interactive)
  (progn
    (next-line 1)
    (re-search-backward "^--- ")
    (setq killto (save-excursion 
		   (progn    
		     (next-line 1)
		     (re-search-forward "^\\@\\@ EOF") 
		     (next-line 1)
		     (beginning-of-line) 
		     (point))))
    (kill-region (point) killto)))

(defun patch-next-hunk ()
  "Move to next hunk."
  (interactive)
  (prog1
    (next-line 1)
    (re-search-forward '"^\\@\\@")
    (beginning-of-line)))

(defun patch-prev-hunk ()
  "Move to previous hunk."
  (interactive)
  (prog1
    (next-line -1)
    (re-search-backward '"^\\@\\@")
    (beginning-of-line)))

(defun patch-next-file ()
  "Move to next file"
  (interactive)
  (prog1
    (next-line 1)
    (re-search-forward '"^---")
    (beginning-of-line)))

(defun patch-prev-file ()
  "Move to preivous file"
  (interactive)
  (prog1
    (next-line -1)
    (re-search-backward '"^---")
    (beginning-of-line)))

;; routines

;;;###autoload
(defun patch-mode (&optional arg)
  "This mode is intended for editing files generated by diff"
  (interactive "p")
  (if (eq major-mode 'patch-mode)
      (error "You are already in patch mode")

    (let ((modified (buffer-modified-p))
	  (inhibit-read-only t)
	  (original-point (1- (point))))
        (patchify-buffer)
        (set-buffer-modified-p modified))

    (use-local-map patch-mode-map)

    ;; Add hooks to repatchify or depatchify on various events.
    (make-local-hook 'after-revert-hook)
    (add-hook 'after-revert-hook 'patch-after-revert-hook nil t)

    (add-hook 'write-contents-hooks 'patch-save-buffer)

    (setq mode-name "Patch")
    (setq major-mode 'patch-mode)

      (progn
	; inherit global values
	(make-local-variable 'patch-hiding)
	(setq patch-hiding (default-value 'patch-hiding))

	(run-hooks 'patch-mode-hook)

	(if patch-initially
	    (hide-all-patchblocks)
	  (show-all-patchblocks))
	(message "Enter Patch mode")
	)

    (make-local-hook 'change-major-mode-hook)
    (add-hook 'change-major-mode-hook 'patch-maybe-depatchify-buffer nil t))
  (run-hooks 'patch-mode-hook))

(defun patch-after-revert-hook ()
  (patchify-buffer)
  (set-buffer-modified-p nil))

(defvar patch-in-save-buffer nil)

(defun patch-save-buffer ()
  "Save a patch format buffer as binary in visited file if modified."
  (interactive)
  (message "(Saving under patch mode")
  (if patch-in-save-buffer nil
    (set-buffer-modified-p (if (buffer-modified-p)
			       (save-excursion
				 (let ((buf (generate-new-buffer " patch"))
				       (name (buffer-name))
				       (file-name (buffer-file-name))
				       (start (point-min))
				       (end (point-max))
				       modified)
				   (set-buffer buf)
				   (insert-buffer-substring name start end)
				   (set-buffer name)
				   (depatchify-buffer)
				   ;; Prevent infinite recursion.
				   (let ((patch-in-save-buffer t)
					 (buffer-file-type t)) ; for ms-dos
				     (save-buffer))
				   (setq modified (buffer-modified-p))
				   (delete-region (point-min) (point-max))
				   (insert-buffer-substring buf start end)
				   (kill-buffer buf)
				   modified))
			     (message "(No changes need to be saved)")
			     nil))
    ;; Return t to indicate we have saved t
    t))

(defun patch-maybe-depatchify-buffer ()
  "Convert a patch format buffer to binary.
Ask the user for confirmation."
  (if (y-or-n-p "Convert contents back to binary format? ")
      (let ((modified (buffer-modified-p))
	    (inhibit-read-only t))
	(depatchify-buffer)
	(remove-hook 'write-contents-hooks 'patch-save-buffer)
	(set-buffer-modified-p modified))))

;;;###autoload
(defun patchify-buffer ()
  "Convert a binary buffer to patch format.
This discards the buffer's undo information."
  (interactive)
  (and buffer-undo-list
       (or (y-or-n-p "Converting to patch format discards undo info; ok? ")
	   (error "Aborted")))
  (setq buffer-undo-list nil)
  (let ((binary-process-output nil) ; for Ms-Dos
	(binary-process-input t)
	(buffer-undo-list t))
    (shell-command-on-region (point-min) (point-max) patchify-command t)))

(defun depatchify-buffer ()
  "Convert a patch format buffer to binary.
This discards the buffer's undo information."
  (interactive)
  (and buffer-undo-list
       (or (y-or-n-p "Converting from patch format discards undo info; ok? ")
	   (error "Aborted")))
  (setq buffer-undo-list nil)
  (let ((binary-process-output t) ; for Ms-Dos
	(binary-process-input nil)
	(buffer-undo-list t))
    (shell-command-on-region (point-min) (point-max) depatchify-command t)))

;;; Following is from hide-ifdef

;; from outline.el with docstring fixed.
(defun patchider-outline-flag-region (from to flag)
  "Hides or shows lines from FROM to TO, according to FLAG.
If FLAG is \\n (newline character) then text is shown, while if FLAG is \\^M
\(control-M) the text is hidden."
  (let ((modp (buffer-modified-p)))
    (unwind-protect (progn
		      (subst-char-in-region from to
			      (if (= flag ?\n) ?\^M ?\n)
			      flag t) )
      (set-buffer-modified-p modp))
    ))

(defun patchider-show-all ()
  "Show all of the text in the current buffer."
  (interactive)
  (patchider-outline-flag-region (point-min) (point-max) ?\n))

;; By putting this on after-revert-hook, we arrange that it only
;; does anything when revert-buffer avoids turning off the mode.
;; (That can happen in VC.)
(defun patchider-before-revert-function ()
  (and (boundp 'patch-mode) patch-mode patch-hiding
       (hide-all-patchblocks t)))
(add-hook 'after-revert-hook 'patchider-before-revert-function)

(defun patch-region (start end)
  "START is the start of a #if or #else form.  END is the ending part.
Everything including these lines is made invisible."
  (patchider-outline-flag-region start end ?\^M)
  )

(defun patchider-show-ifdef-region (start end)
  "Everything between START and END is made visible."
  (patchider-outline-flag-region start end ?\n)
  )


;===%%SF%% parsing (Start)  ===
;;;  The code that understands what ifs and ifdef in files look like.

(defconst patchider-ifx-regexp "^--- ")
(defconst patchider-endif-regexp "^\\@\\@ EOF")
(defconst patchider-ifx-else-endif-regexp
  (concat patchider-ifx-regexp "\\|" patchider-endif-regexp))

(defun patchider-find-any-ifX ()
  "Move to next #if..., or #ifndef, at point or after."
;  (message "find ifX at %d" (point))
  (prog1
      (re-search-forward patchider-ifx-regexp (point-max) t)
    (beginning-of-line)))

(defun patchider-find-next-relevant ()
  "Move to next #if..., #else, or #endif, after the current line."
;  (message "patchider-find-next-relevant at %d" (point))
  (end-of-line)
  ; avoid infinite recursion by only going to beginning of line if match found
  (if (re-search-forward patchider-ifx-else-endif-regexp (point-max) t)
      (beginning-of-line)))

(defun patchider-find-previous-relevant ()
  "Move to previous #if..., #else, or #endif, before the current line."
;  (message "patchider-find-previous-relevant at %d" (point))
  (beginning-of-line)
  ; avoid infinite recursion by only going to beginning of line if match found
  (if (re-search-backward patchider-ifx-else-endif-regexp (point-min) t)
     (beginning-of-line)))


(defun patchider-looking-at-ifX ()		;; Should eventually see #if
  (looking-at patchider-ifx-regexp))
(defun patchider-looking-at-endif ()
  (looking-at patchider-endif-regexp))


(defun patchider-ifdef-to-endif ()
  "If positioned at #ifX or #else form, skip to corresponding #endif."
;  (message "patchider-ifdef-to-endif at %d" (point)) (sit-for 1)
  (patchider-find-next-relevant)
  (cond ((patchider-looking-at-ifX)
	 (patchider-ifdef-to-endif) ; find endif of nested if
	 (patchider-ifdef-to-endif)) ; find outer endif or else
	((patchider-looking-at-endif)
	 'done)
	(t
	 (error "Mismatched #ifdef #endif pair"))))

(defun patchider-endif-to-ifdef ()
  "If positioned at #endif form, skip backward to corresponding #ifX."
;  (message "patchider-endif-to-ifdef at %d" (point))
  (let ((start (point)))
    (patchider-find-previous-relevant)
    (if (= start (point))
	(error "Mismatched #ifdef #endif pair")))
  (cond ((patchider-looking-at-endif)
	 (patchider-endif-to-ifdef) ; find beginning of nested if
	 (patchider-endif-to-ifdef)) ; find beginning of outer if or else
	((patchider-looking-at-ifX)
	 'done)
	(t)))			; never gets here


(defun up-ifdef ()
  "Move point to beginning of enclosing ifdef or else-part."
  (interactive)
  (beginning-of-line)
  (let ((start (point)))
    (if (not (patchider-looking-at-endif))
	(patchider-find-previous-relevant))
    (if (patchider-looking-at-endif)
	(patchider-endif-to-ifdef))
      (if (= start (point))
	  (error "No previous #ifdef"))))

;;; A range is a structure with four components:
;;; ELSE-P	True if there was an else clause for the ifdef.
;;; START	The start of the range. (beginning of line)
;;; ELSE	The else marker (beginning of line)
;;;			Only valid if ELSE-P is true.
;;; END		The end of the range.  (beginning of line)

(defun patchider-make-range (else-p start end &optional else)
  (list else-p start else end))

(defun patchider-range-else-p (range)  (elt range 0))
(defun patchider-range-start (range) (elt range 1))
(defun patchider-range-else (range) (elt range 2))
(defun patchider-range-end (range) (elt range 3))



;;; Find-Range
;;; The workhorse, it delimits the #if region.  Reasonably simple:
;;; Skip until an #else or #endif is found, remembering positions.  If
;;; an #else was found, skip some more, looking for the true #endif.

(defun patchider-find-range ()
  "Returns a Range structure describing the current #if region.
Point is left unchanged."
;  (message "patchider-find-range at %d" (point))
  (save-excursion
    (beginning-of-line)
    (let ((start (point))
	  (else-p nil)
	  (else nil)
	  (end nil))
      ;; Part one.  Look for either #endif or #else.
      ;; This loop-and-a-half dedicated to E. Dijkstra.
      (patchider-find-next-relevant)
      (while (patchider-looking-at-ifX)		; Skip nested ifdef
	(patchider-ifdef-to-endif)
	(patchider-find-next-relevant))
      ;; Found either a #else or an #endif.
      (cond (t
	     (setq end (point)) ; (save-excursion (end-of-line) (point))
	     ))
      ;; If found #else, look for #endif.
      (if else-p
	  (progn
	    (patchider-find-next-relevant)
	    (while (patchider-looking-at-ifX)	; Skip nested ifdef
	      (patchider-ifdef-to-endif)
	      (patchider-find-next-relevant))
	    (setq end (point))  ; (save-excursion (end-of-line) (point))
	    ))
      (patchider-make-range else-p start end else))))

	  
;;; A bit slimy.
;;; NOTE:  If there's an #ifdef at the beginning of the file, we can't
;;; hide it.  There's no previous newline to replace.  If we added
;;; one, we'd throw off all the counts.  Feh.

(defun patchider-hide-line (point)
  "Hide the line containing point.  Does nothing if `patch-lines' is nil."
  (if patch-lines
      (save-excursion
	(goto-char point)
	(let ((modp (buffer-modified-p)))
	  (unwind-protect
	      (progn
		(beginning-of-line)
		(if (not (= (point) 1))
		    (patch-region (1- (point)) (point))))
	    (set-buffer-modified-p modp))
	  ))
    ))
		  
(defun patchider-possibly-hide ()
  "Called at #ifX expression, this hides those parts that should be hidden.
It uses the judgement of `patch-evaluator'."
;  (message "patchider-possibly-hide") (sit-for 1)
    (let ((range (patchider-find-range)))
;      (message "test = %s" test) (sit-for 1)
      
      (patchider-hide-line (patchider-range-end range))
      (patch-region (point)
				  (1- (patchider-range-end range)))
	    
      (patchider-hide-line (patchider-range-start range))	; Always hide start.
      (goto-char (patchider-range-end range))
      (end-of-line)
      ))


(defun patch-guts ()
  "Does most of the work of `hide-all-patchblocks'.
It does not do the work that's pointless to redo on a recursive entry."
;  (message "patch-guts")
  (save-excursion
    (goto-char (point-min))
    (while (patchider-find-any-ifX)
      (patchider-possibly-hide))))

;;;###autoload
(defvar patch-initially nil
  "*Non-nil means call `hide-all-patchblocks' when Patch mode is first activated.")

;;;###autoload
(defvar patch-read-only nil
  "*Set to non-nil if you want buffer to be read-only while hiding text.")

(defvar patchider-outside-read-only nil
  "Internal variable.  Saves the value of `buffer-read-only' while hiding.")

;;;###autoload
(defvar patch-lines nil
  "*Non-nil means hide the #ifX, #else, and #endif lines.")

(defvar patch-hiding nil
  "")

(defun hide-all-patchblocks (&optional nomsg)
  "Hide the contents of some #ifdefs.  
Assume that defined symbols have been added to `patch-env'.  
The text hidden is the text that would not be included by the C
preprocessor if it were given the file with those symbols defined.

Turn off hiding by calling `show-all-patchblocks'."

  (interactive)
  (message "Hiding...")
  (setq patchider-outside-read-only buffer-read-only)
  (if patch-hiding
      (show-all-patchblocks))			; Otherwise, deep confusion.
  (let ((inhibit-read-only t))
    (setq selective-display t)
    (setq patch-hiding t)
    (patch-guts))
  (setq buffer-read-only (or patch-read-only patchider-outside-read-only))
  (or nomsg
      (message "Hiding done")))


(defun show-all-patchblocks ()
  "Cancel the effects of `patch': show the contents of all #ifdefs."
  (interactive)
  (setq buffer-read-only patchider-outside-read-only)
  (setq selective-display nil)	; defaults
  (let ((inhibit-read-only t))
    (patchider-show-all))
  (setq patch-hiding nil))


(defun patchider-find-patchblock ()
  "Utility for hide and show `patchblock'.
Set top and bottom of patchblock."
  (let (max-bottom)
  (save-excursion
    (beginning-of-line)
    (if (not (patchider-looking-at-ifX))
	(up-ifdef))
    (setq top (point))
    (patchider-ifdef-to-endif)
    (setq max-bottom (1- (point))))
  (save-excursion
    (beginning-of-line)
    (if (not (patchider-looking-at-endif))
	(patchider-find-next-relevant))
    (while (patchider-looking-at-ifX)
      (patchider-ifdef-to-endif)
      (patchider-find-next-relevant))
    (setq bottom (min max-bottom (1- (point))))))
  )


(defun hide-patchblock ()
  "Hide the patchblock (true or false part) enclosing or before the cursor."
  (interactive)
  (setq selective-display t)
  (let (top bottom (inhibit-read-only t))
    (patchider-find-patchblock) ; set top and bottom - dynamic scoping
    (patch-region top bottom)
    (if patch-lines
	(progn
	  (patchider-hide-line top)
	  (patchider-hide-line (1+ bottom))))
    (setq patch-hiding t))
  (setq buffer-read-only (or patch-read-only patchider-outside-read-only)))


(defun show-patchblock ()
  "Show the patchblock (true or false part) enclosing or before the cursor."
  (interactive)
  (let ((inhibit-read-only t))
    (if patch-lines
	(save-excursion
	  (beginning-of-line)
	  (patchider-show-ifdef-region (1- (point)) (progn (end-of-line) (point))))

      (let (top bottom)
	(patchider-find-patchblock)
	(patchider-show-ifdef-region (1- top) bottom)))))

(provide 'patch-mode)
